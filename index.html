<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LLM Agent POC - Multi-Tool Reasoning</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css"
      rel="stylesheet"
    />
    <style>
      .chat-container {
        height: 60vh;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        padding: 1rem;
        background-color: #f8f9fa;
      }

      .message {
        margin-bottom: 1rem;
        padding: 0.75rem;
        border-radius: 0.5rem;
      }

      .message.user {
        background-color: #e3f2fd;
        border-left: 4px solid #2196f3;
      }

      .message.agent {
        background-color: #f3e5f5;
        border-left: 4px solid #9c27b0;
      }

      .message.tool {
        background-color: #e8f5e8;
        border-left: 4px solid #4caf50;
        font-family: monospace;
        font-size: 0.9em;
      }

      .message.error {
        background-color: #ffebee;
        border-left: 4px solid #f44336;
      }

      .thinking {
        opacity: 0.7;
        font-style: italic;
      }

      .code-result {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
        padding: 0.5rem;
        margin-top: 0.5rem;
        font-family: monospace;
        font-size: 0.9em;
      }

      .search-result {
        background-color: #fff;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
        padding: 0.75rem;
        margin: 0.5rem 0;
      }

      .search-result .title {
        font-weight: bold;
        color: #1976d2;
        margin-bottom: 0.25rem;
      }

      .search-result .snippet {
        color: #666;
        font-size: 0.9em;
      }
    </style>
  </head>
  <body>
    <div class="container-fluid py-3">
      <div class="row">
        <div class="col-12">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <h1 class="h3 mb-0">
              <i class="bi bi-robot"></i> LLM Agent POC
              <small class="text-muted">Multi-Tool Reasoning</small>
            </h1>
            <div>
              <button id="configBtn" class="btn btn-outline-secondary me-2">
                <i class="bi bi-gear"></i> Configure LLM
              </button>
              <button id="searchConfigBtn" class="btn btn-outline-primary">
                <i class="bi bi-search"></i> Configure Search
              </button>
            </div>
          </div>

          <div id="chatContainer" class="chat-container mb-3">
            <div class="message agent">
              <strong>Agent:</strong> Hello! I'm an LLM-powered agent that can
              help you with various tasks. I can search the web, execute code,
              and use AI workflows. What would you like me to help you with
              today?
            </div>
          </div>

          <div class="input-group">
            <input
              type="text"
              id="userInput"
              class="form-control"
              placeholder="Type your message here..."
              maxlength="1000"
            />
            <button id="sendBtn" class="btn btn-primary" type="button">
              <i class="bi bi-send"></i> Send
            </button>
          </div>

          <div class="mt-2">
            <small class="text-muted">
              Available tools: Google Search, AI Pipe workflows, JavaScript
              execution
            </small>
            <br />
            <small class="text-muted">
              <label class="form-check-label">
                <input
                  type="checkbox"
                  id="enableTools"
                  class="form-check-input"
                  checked
                />
                Enable tools (uncheck for simple chat mode)
              </label>
              <br />
              <label class="form-check-label">
                <input
                  type="checkbox"
                  id="useRealSearch"
                  class="form-check-input"
                />
                Use real Google Search API (configure with button above)
              </label>
            </small>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- External Libraries and Main Script -->
    <script type="module">
      // Import required libraries
      import { bootstrapAlert } from "https://cdn.jsdelivr.net/npm/bootstrap-alert@1";
      import { openaiConfig } from "https://cdn.jsdelivr.net/npm/bootstrap-llm-provider@1.2";
      import { getProfile } from "https://aipipe.org/aipipe.js";

      // Global variables
      let llmConfig = null;
      let conversationHistory = [];
      let isProcessing = false;

      // DOM elements
      const chatContainer = document.getElementById("chatContainer");
      const userInput = document.getElementById("userInput");
      const sendBtn = document.getElementById("sendBtn");
      const configBtn = document.getElementById("configBtn");

      // Tool definitions for LLM
      const tools = [
        {
          type: "function",
          function: {
            name: "google_search",
            description:
              "Search Google for information and return snippet results",
            parameters: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The search query",
                },
                num_results: {
                  type: "number",
                  description:
                    "Number of results to return (default: 5, max: 10)",
                  default: 5,
                },
              },
              required: ["query"],
            },
          },
        },
        {
          type: "function",
          function: {
            name: "aipipe_workflow",
            description: "Execute an AI workflow using the aipipe proxy API",
            parameters: {
              type: "object",
              properties: {
                prompt: {
                  type: "string",
                  description: "The prompt to send to the AI workflow",
                },
                model: {
                  type: "string",
                  description: "The model to use (default: gpt-4o-mini)",
                  default: "gpt-4o-mini",
                },
              },
              required: ["prompt"],
            },
          },
        },
        {
          type: "function",
          function: {
            name: "execute_javascript",
            description: "Execute JavaScript code and return the result",
            parameters: {
              type: "object",
              properties: {
                code: {
                  type: "string",
                  description: "The JavaScript code to execute",
                },
              },
              required: ["code"],
            },
          },
        },
      ];

      // Initialize the application
      async function initialize() {
        try {
          // Check for AI Pipe authentication
          const { token, email } = getProfile();

          // If we have URL parameters, clear them after getProfile() processes them
          if (window.location.href.includes("aipipe_token")) {
            const cleanUrl = window.location.href.split("?")[0];
            window.history.replaceState({}, document.title, cleanUrl);
          }

          if (!token) {
            // Show manual instructions if auto-redirect might not work
            const isFileProtocol = window.location.protocol === "file:";

            bootstrapAlert({
              title: "Authentication Required",
              body: isFileProtocol
                ? "For best results, serve this file via HTTP (e.g., python -m http.server). Click OK to continue with AI Pipe login."
                : "Redirecting to AI Pipe for authentication...",
              color: "warning",
              autohide: false,
            });

            if (isFileProtocol) {
              // For file:// URLs, provide manual instructions
              setTimeout(() => {
                if (
                  confirm(
                    "Click OK to open AI Pipe login. After logging in, manually return to this page."
                  )
                ) {
                  window.open(
                    `https://aipipe.org/login?redirect=${encodeURIComponent(
                      window.location.href
                    )}`,
                    "_blank"
                  );
                }
              }, 3000);
            } else {
              // For HTTP URLs, do automatic redirect
              setTimeout(() => {
                window.location = `https://aipipe.org/login?redirect=${encodeURIComponent(
                  window.location.href
                )}`;
              }, 2000);
            }
            return;
          }

          console.log("Authenticated user:", email);

          // Load saved search configuration
          const savedSearchConfig = localStorage.getItem("searchConfig");
          if (savedSearchConfig) {
            window.searchConfig = JSON.parse(savedSearchConfig);
          }

          // Setup LLM configuration
          await setupLLMConfig();

          // Event listeners
          sendBtn.addEventListener("click", handleSendMessage);
          userInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              handleSendMessage();
            }
          });
          configBtn.addEventListener("click", () => setupLLMConfig(true));

          // Add search configuration button handler
          const searchConfigBtn = document.getElementById("searchConfigBtn");
          searchConfigBtn.addEventListener("click", setupSearchConfig);

          bootstrapAlert({
            body: "Agent initialized successfully!",
            color: "success",
          });
        } catch (error) {
          console.error("Initialization error:", error);
          bootstrapAlert({
            title: "Initialization Error",
            body: error.message,
            color: "danger",
          });
        }
      }

      async function setupLLMConfig(forceShow = false) {
        try {
          llmConfig = await openaiConfig({
            show: forceShow,
            defaultBaseUrls: [
              "https://aipipe.org/openrouter/v1",
              "https://aipipe.org/openai/v1",
              "https://api.openai.com/v1",
            ],
            help: '<div class="alert alert-info">Use AI Pipe for free access, or provide your own OpenAI/OpenRouter API key.</div>',
          });

          if (forceShow) {
            bootstrapAlert({
              body: "LLM configuration updated successfully!",
              color: "success",
            });
          }
        } catch (error) {
          console.error("LLM config error:", error);
          bootstrapAlert({
            title: "Configuration Error",
            body: "Failed to configure LLM provider. Please try again.",
            color: "danger",
          });
          throw error;
        }
      }

      async function setupSearchConfig() {
        const currentConfig = JSON.parse(
          localStorage.getItem("searchConfig") || "{}"
        );

        const apiKey = prompt(
          "Enter your Google Custom Search API Key:",
          currentConfig.apiKey || ""
        );
        if (!apiKey) return;

        const searchEngineId = prompt(
          "Enter your Search Engine ID:",
          currentConfig.searchEngineId || ""
        );
        if (!searchEngineId) return;

        // Save configuration
        const config = { apiKey, searchEngineId };
        localStorage.setItem("searchConfig", JSON.stringify(config));
        window.searchConfig = config;

        bootstrapAlert({
          body: "Search API configuration saved successfully!",
          color: "success",
        });
      }

      function addMessage(role, content, type = "text") {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${role}`;

        let html = `<strong>${
          role.charAt(0).toUpperCase() + role.slice(1)
        }:</strong> `;

        if (type === "html") {
          html += content;
        } else {
          html += escapeHtml(content);
        }

        messageDiv.innerHTML = html;
        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;

        return messageDiv;
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      async function handleSendMessage() {
        if (isProcessing || !userInput.value.trim() || !llmConfig) return;

        const userMessage = userInput.value.trim();
        userInput.value = "";
        isProcessing = true;
        sendBtn.disabled = true;

        // Add user message to chat
        addMessage("user", userMessage);
        conversationHistory.push({ role: "user", content: userMessage });

        try {
          await agentLoop();
        } catch (error) {
          console.error("Agent loop error:", error);
          addMessage("error", `Error: ${error.message}`);
          bootstrapAlert({
            title: "Agent Error",
            body: error.message,
            color: "danger",
          });
        } finally {
          isProcessing = false;
          sendBtn.disabled = false;
          userInput.focus();
        }
      }

      async function agentLoop() {
        let loopCount = 0;
        const maxLoops = 3; // Limit the number of tool execution loops

        while (loopCount < maxLoops) {
          loopCount++;

          try {
            // Check if tools are enabled
            const enableTools = document.getElementById("enableTools").checked;
            const toolsToUse = enableTools ? tools : undefined;

            // Call LLM with conversation history and tools (if enabled)
            const response = await callLLM(conversationHistory, toolsToUse);

            // Handle tool calls if any (only if tools are enabled)
            if (
              enableTools &&
              response.tool_calls &&
              response.tool_calls.length > 0
            ) {
              // Add assistant message with tool calls to history first
              conversationHistory.push({
                role: "assistant",
                content: response.content || null,
                tool_calls: response.tool_calls,
              });

              // Execute each tool call
              for (const toolCall of response.tool_calls) {
                try {
                  const result = await handleToolCall(toolCall);
                  const toolMessage = {
                    role: "tool",
                    content:
                      typeof result === "string"
                        ? result
                        : JSON.stringify(result, null, 2),
                    tool_call_id: toolCall.id,
                  };
                  conversationHistory.push(toolMessage);
                } catch (error) {
                  console.error("Tool call error:", error);
                  const errorMessage = {
                    role: "tool",
                    content: `Error executing ${toolCall.function.name}: ${error.message}`,
                    tool_call_id: toolCall.id,
                  };
                  conversationHistory.push(errorMessage);
                  addMessage("error", `Tool error: ${error.message}`);
                }
              }
              // Continue the loop to get the final response after tool execution
            } else {
              // No tool calls - add the final response and end
              if (response.content) {
                addMessage("agent", response.content);
                conversationHistory.push({
                  role: "assistant",
                  content: response.content,
                });
              }
              break; // End the loop
            }
          } catch (error) {
            console.error(`Agent loop error:`, error);
            addMessage("error", `Agent error: ${error.message}`);
            break;
          }
        }

        // Safety check - if we hit max loops, add a final message
        if (loopCount >= maxLoops) {
          addMessage(
            "agent",
            "I've completed the requested actions. Is there anything else you'd like me to help with?"
          );
        }
      }

      async function callLLM(messages, tools) {
        const { token } = getProfile();

        // Clean and validate messages for OpenAI format
        const cleanMessages = [];
        for (let i = 0; i < messages.length; i++) {
          const msg = messages[i];

          if (msg.role === "assistant" && msg.tool_calls) {
            // Assistant message with tool calls
            cleanMessages.push({
              role: "assistant",
              content: msg.content || null,
              tool_calls: msg.tool_calls,
            });

            // Find corresponding tool responses
            for (const toolCall of msg.tool_calls) {
              const toolResponse = messages.find(
                (m) => m.role === "tool" && m.tool_call_id === toolCall.id
              );
              if (toolResponse) {
                cleanMessages.push({
                  role: "tool",
                  tool_call_id: toolCall.id,
                  content: toolResponse.content,
                });
              }
            }
          } else if (msg.role === "tool") {
            // Skip tool messages - they're handled above
            continue;
          } else {
            // Regular user/assistant messages
            cleanMessages.push({
              role: msg.role,
              content: msg.content,
            });
          }
        }

        const payload = {
          model: "openai/gpt-4o-mini",
          messages: cleanMessages,
          temperature: 0.7,
          max_tokens: 1000,
        };

        // Only add tools if we have any and they're enabled
        if (tools && tools.length > 0) {
          payload.tools = tools;
          payload.tool_choice = "auto";
        }

        console.log(
          "Sending request to LLM:",
          JSON.stringify(payload, null, 2)
        );

        const response = await fetch(`${llmConfig.baseUrl}/chat/completions`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token || llmConfig.apiKey}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error("LLM API error details:", errorText);
          throw new Error(
            `LLM API error: ${response.status} ${response.statusText}. Details: ${errorText}`
          );
        }

        const data = await response.json();
        console.log("LLM response:", data);
        return data.choices[0].message;
      }

      async function handleToolCall(toolCall) {
        const { name, arguments: args } = toolCall.function;
        const parsedArgs = JSON.parse(args);

        addMessage(
          "tool",
          `Executing ${name} with: ${JSON.stringify(parsedArgs, null, 2)}`
        );

        switch (name) {
          case "google_search":
            return await executeGoogleSearch(parsedArgs);
          case "aipipe_workflow":
            return await executeAIPipeWorkflow(parsedArgs);
          case "execute_javascript":
            return await executeJavaScript(parsedArgs);
          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      }

      async function executeGoogleSearch(args) {
        const { query, num_results = 5 } = args;
        const useRealSearch =
          document.getElementById("useRealSearch")?.checked || false;

        if (useRealSearch) {
          // Real search implementation (requires API key)
          return await executeRealGoogleSearch(args);
        } else {
          // Mock search (default)
          return await executeMockGoogleSearch(args);
        }
      }

      async function executeRealGoogleSearch(args) {
        const { query, num_results = 5 } = args;

        try {
          // Using environment variables or configuration
          let API_KEY = "";
          let SEARCH_ENGINE_ID = "";

          // Try to get from window.searchConfig (set by configuration button)
          if (window.searchConfig) {
            API_KEY = window.searchConfig.apiKey;
            SEARCH_ENGINE_ID = window.searchConfig.searchEngineId;
          }

          if (!API_KEY || !SEARCH_ENGINE_ID) {
            throw new Error(
              'Google API credentials not configured. Please click "Configure Search" button.'
            );
          }

          return await executeRealGoogleSearchWithCredentials(
            args,
            API_KEY,
            SEARCH_ENGINE_ID
          );
        } catch (error) {
          console.warn(
            "Real search failed, falling back to mock:",
            error.message
          );
          addMessage(
            "error",
            `Google Search API Error: ${error.message}. Falling back to mock data.`
          );
          return await executeMockGoogleSearch(args);
        }
      }

      async function executeRealGoogleSearchWithCredentials(
        args,
        apiKey,
        searchEngineId
      ) {
        const { query, num_results = 5 } = args;

        const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(
          query
        )}&num=${Math.min(num_results, 10)}`;

        console.log("Making Google Search API call...");
        const response = await fetch(url);

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(
            `Google API error: ${response.status} - ${
              errorData.error?.message || response.statusText
            }`
          );
        }

        const data = await response.json();

        if (!data.items || data.items.length === 0) {
          throw new Error("No search results found");
        }

        const results = data.items.map((item) => ({
          title: item.title,
          snippet: item.snippet || "No description available",
          url: item.link,
        }));

        // Display real search results
        const resultHtml = results
          .map(
            (result) =>
              `<div class="search-result">
                    <div class="title"><a href="${escapeHtml(
                      result.url
                    )}" target="_blank">${escapeHtml(result.title)}</a></div>
                    <div class="snippet">${escapeHtml(result.snippet)}</div>
                    <small class="text-muted">${escapeHtml(result.url)}</small>
                </div>`
          )
          .join("");

        const messageDiv = addMessage("tool", "", "html");
        messageDiv.innerHTML = `<strong>Tool:</strong> üîç Real Google Search Results (${results.length} results):<br>${resultHtml}
                <small class="text-success"><br><em>‚úÖ Using real Google Custom Search API</em></small>`;

        return `Found ${
          results.length
        } real search results for "${query}": ${results
          .map((r) => r.title)
          .join(", ")}. Links: ${results.map((r) => r.url).join(", ")}`;
      }

      async function executeMockGoogleSearch(args) {
        const { query, num_results = 5 } = args;

        try {
          // Mock search results with query customization
          const results = [
            {
              title: `Learn ${query} - Official Documentation`,
              snippet: `Official documentation and tutorials for ${query}. Start here for comprehensive guides and examples.`,
              url: "https://docs.python.org/3/tutorial/",
            },
            {
              title: `${query} Tutorial for Beginners - Real Python`,
              snippet: `Step-by-step tutorial covering ${query} fundamentals with practical examples and exercises.`,
              url: "https://realpython.com/python-basics/",
            },
            {
              title: `Free ${query} Course - Codecademy`,
              snippet: `Interactive online course covering ${query} from basics to advanced topics. Hands-on coding practice included.`,
              url: "https://www.codecademy.com/learn/learn-python",
            },
          ].slice(0, num_results);

          // Display search results in chat
          const resultHtml = results
            .map(
              (result) =>
                `<div class="search-result">
                        <div class="title">${escapeHtml(result.title)}</div>
                        <div class="snippet">${escapeHtml(result.snippet)}</div>
                        <small class="text-muted">${escapeHtml(
                          result.url
                        )}</small>
                    </div>`
            )
            .join("");

          const messageDiv = addMessage("tool", "", "html");
          messageDiv.innerHTML = `<strong>Tool:</strong> Mock Google Search Results (${results.length} results):<br>${resultHtml}
                    <small class="text-muted"><br><em>Note: Using mock data. For production, integrate with Google Custom Search API.</em></small>`;

          return `Found ${
            results.length
          } search results for "${query}". Key resources include: ${results
            .map((r) => r.title)
            .join(
              ", "
            )}. These cover official documentation, beginner tutorials, and interactive courses.`;
        } catch (error) {
          throw new Error(`Google Search failed: ${error.message}`);
        }
      }

      async function executeAIPipeWorkflow(args) {
        const { prompt, model = "gpt-4o-mini" } = args;
        const { token } = getProfile();

        try {
          const response = await fetch(
            "https://aipipe.org/openrouter/v1/chat/completions",
            {
              method: "POST",
              headers: {
                Authorization: `Bearer ${token}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                model: "openai/gpt-4o-mini",
                messages: [{ role: "user", content: prompt }],
                temperature: 0.7,
              }),
            }
          );

          if (!response.ok) {
            throw new Error(`AI Pipe workflow failed: ${response.status}`);
          }

          const data = await response.json();
          const result = data.choices[0].message.content;

          addMessage("tool", `AI Pipe Result: ${result}`);
          return result;
        } catch (error) {
          throw new Error(`AI Pipe workflow failed: ${error.message}`);
        }
      }

      async function executeJavaScript(args) {
        const { code } = args;

        try {
          // Create a safer execution environment
          let result;

          // Try to evaluate the code safely
          try {
            // If it's a simple expression, evaluate it directly
            result = eval(code);
          } catch (evalError) {
            // If direct eval fails, try wrapping it in a function
            try {
              const wrappedCode = `(function() { ${code} })()`;
              result = eval(wrappedCode);
            } catch (wrapError) {
              // If both fail, try executing as-is in a more permissive way
              const func = new Function(code);
              result = func();
            }
          }

          const resultStr =
            typeof result === "object" && result !== null
              ? JSON.stringify(result, null, 2)
              : String(result);

          const messageDiv = addMessage("tool", "", "html");
          messageDiv.innerHTML = `<strong>Tool:</strong> JavaScript Execution:
                    <div class="code-result">
                        <strong>Code:</strong> <code>${escapeHtml(
                          code
                        )}</code><br>
                        <strong>Result:</strong> <pre>${escapeHtml(
                          resultStr
                        )}</pre>
                    </div>`;

          return `Code executed successfully. Result: ${resultStr}`;
        } catch (error) {
          const errorMsg = `JavaScript execution failed: ${error.message}`;
          addMessage("error", errorMsg);
          throw new Error(errorMsg);
        }
      }

      // Initialize the application when the page loads
      document.addEventListener("DOMContentLoaded", initialize);

      // Make functions available globally for debugging
      window.agentDebug = {
        llmConfig,
        conversationHistory,
        addMessage,
        callLLM,
        handleToolCall,
      };
    </script>
  </body>
</html>
